<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Snake ‚Äî Single or Local Multiplayer + Bonus Items + VFX</title>
  <style>
    :root { --bg:#0f1220; --panel:#1b2038; --accent:#7cf49a; --accent2:#6ea8fe; --danger:#ff6b6b; --text:#e9ecf1; --muted:#9aa4b2; --grid:#1e2442; }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:radial-gradient(1200px 800px at 70% 10%, #1a1f35 0%, var(--bg) 60%);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial,"Noto Sans"}
    .wrap{display:grid;grid-template-columns:320px 1fr;gap:16px;height:100%;padding:16px}
    .panel{background:linear-gradient(180deg,rgba(255,255,255,0.04),rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.08);border-radius:16px;padding:14px;box-shadow:0 12px 40px rgba(0,0,0,0.35),inset 0 -50px 100px rgba(255,255,255,0.02)}
    h1{font-size:22px;margin:8px 0 12px;letter-spacing:.2px}
    h2{font-size:14px;margin:14px 0 8px;color:var(--muted);font-weight:600;text-transform:uppercase;letter-spacing:.8px}
    .btn{appearance:none;border:1px solid rgba(255,255,255,0.12);background:#121427;color:var(--text);padding:10px 12px;border-radius:12px;cursor:pointer;transition:120ms transform,120ms background,120ms border-color;font-weight:600;width:100%;text-align:left;display:grid;grid-template-columns:1fr auto;align-items:center;gap:8px}
    .btn:hover{transform:translateY(-1px);border-color:rgba(255,255,255,0.2)}
    .btn.primary{background:linear-gradient(180deg,rgba(124,244,154,0.18),rgba(124,244,154,0.08));border-color:rgba(124,244,154,0.35)}
    .btn.danger{background:linear-gradient(180deg,rgba(255,107,107,0.18),rgba(255,107,107,0.08));border-color:rgba(255,107,107,0.35)}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .small{font-size:12px;color:var(--muted)}
    label{display:grid;gap:6px;font-size:13px}
    input[type=range],input[type=number]{width:100%}
    .kv{display:grid;grid-template-columns:auto 1fr;gap:8px 12px;align-items:center}
    .kv div:nth-child(odd){color:var(--muted)}
    .gameWrap{position:relative;display:grid;place-items:center}
    canvas{background:repeating-linear-gradient(0deg,var(--grid),var(--grid) 1px,transparent 1px,transparent 24px),repeating-linear-gradient(90deg,var(--grid),var(--grid) 1px,transparent 1px,transparent 24px),linear-gradient(180deg,#0b0e1a,#0c1021);border-radius:16px;border:1px solid rgba(255,255,255,0.1);box-shadow:0 12px 40px rgba(0,0,0,0.45)}
    @media (max-width:960px){.wrap{grid-template-columns:1fr}}
    .pill{display:inline-block;padding:.2rem .45rem;border-radius:9999px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12);font-size:12px}
  </style>
</head>
<body>
  <div class="wrap">
    <aside class="panel">
      <h1>üêç Snake</h1>
      <div class="kv" id="scoreboard">
        <div>Mode</div><div id="modeName">‚Äî</div>
        <div>Score P1</div><div id="score1">0</div>
        <div>Score P2</div><div id="score2">0</div>
        <div>Highscore</div><div id="hi">0</div>
        <div>Speed</div><div><span id="speedLabel">10</span> ticks/s</div>
        <div>Foods</div><div id="foodsLabel">4</div>
        <div>Items</div><div id="itemsLabel" class="pill">0 on board</div>
      </div>

      <h2>Play</h2>
      <div class="row">
        <button class="btn primary" id="btnSingle">üßç Single Player</button>
        <button class="btn" id="btnLocal">üë• Local Versus</button>
      </div>
      <div class="row" style="margin-top:10px">
        <button class="btn" id="btnPause">‚èØÔ∏è Pause</button>
        <button class="btn danger" id="btnRestart">üîÅ Restart</button>
      </div>

      <h2>Settings</h2>
      <label>Speed <input type="range" id="speed" min="5" max="25" step="1" value="10"/></label>
      <label>Board Size
        <div class="row">
          <input type="number" id="cols" min="12" max="64" value="28"/>
          <input type="number" id="rows" min="10" max="48" value="22"/>
        </div>
      </label>
      <label><input type="checkbox" id="wrap" checked/> Wrap walls (classic)</label>
      <label><input type="checkbox" id="hazards"/> Random hazards</label>
      <label>Food count <input type="number" id="foodCount" min="1" max="10" value="4"/></label>
      <label>Max items <input type="number" id="itemMax" min="0" max="6" value="2"/></label>
      <p class="small">Space = pause. P1: Arrows, P2: WASD. Center overlay removed.</p>

      <h2>Legend</h2>
      <div class="kv small">
        <div>üçã Food</div><div>Yellow square with outline</div>
        <div>‚ò†Ô∏è Hazard</div><div>Red X (don‚Äôt touch)</div>
        <div>üåÄ Shrink</div><div>Reduce your snake by <b>30%</b></div>
        <div>‚≠ê Bonus</div><div>+50 score instantly</div>
        <div>üí£ Clear</div><div>Remove all hazards</div>
      </div>
    </aside>
    <main class="gameWrap">
      <canvas id="game" width="672" height="528" aria-label="Snake game canvas" role="img"></canvas>
    </main>
  </div>

  <script>
  (()=>{
    const rnd=n=>Math.floor(Math.random()*n);
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const canvas=document.getElementById('game');
    const ctx=canvas.getContext('2d');
    const ui={sbMode:modeName,sb1:score1,sb2:score2,hi:hi,speed:speed,speedLabel:speedLabel,cols:cols,rows:rows,wrap:wrap,hazards:hazards,foodCount:foodCount,foodsLabel:foodsLabel,itemMax:itemMax,itemsLabel:itemsLabel,btnPause:btnPause,btnRestart:btnRestart,btnSingle:btnSingle,btnLocal:btnLocal};

    const storageKey='snake.local.v2';
    const store=JSON.parse(localStorage.getItem(storageKey)||'{}');
    let CFG={cols:Number(store.cols)||28,rows:Number(store.rows)||22,cell:24,speed:Number(store.speed)||10,wrap:store.wrap!==undefined?!!store.wrap:true,hazards:!!store.hazards,foodCount:Number(store.foodCount)||4,itemMax:Number(store.itemMax)||2};
    function saveConfig(){localStorage.setItem(storageKey,JSON.stringify({cols:CFG.cols,rows:CFG.rows,speed:CFG.speed,wrap:CFG.wrap,hazards:CFG.hazards,foodCount:CFG.foodCount,itemMax:CFG.itemMax}))}
    function resizeCanvas(){canvas.width=CFG.cols*CFG.cell;canvas.height=CFG.rows*CFG.cell}

    const DIRS={UP:[0,-1],DOWN:[0,1],LEFT:[-1,0],RIGHT:[1,0]};
    const OPP={UP:'DOWN',DOWN:'UP',LEFT:'RIGHT',RIGHT:'LEFT'};
    function newSnake(id,color,start,dir){return{id,color,body:[start],dir,pendingDir:dir,grow:2,alive:true,score:0}}

    function equal(a,b){return a&&b&&a.x===b.x&&a.y===b.y}
    function wrapPos(p){return{x:(p.x+CFG.cols)%CFG.cols,y:(p.y+CFG.rows)%CFG.rows}}
    function inBounds(p){return p.x>=0&&p.x<CFG.cols&&p.y>=0&&p.y<CFG.rows}

    function newFood(state){let p;let tries=0;do{p={x:rnd(state.cols),y:rnd(state.rows)};tries++;if(tries>2000)break}while(collisionAt(state,p));return p}
    function newHazards(state,count){const hz=[];for(let i=0;i<count;i++){let p;let tries=0;do{p={x:rnd(state.cols),y:rnd(state.rows)};tries++;if(tries>2000)break}while(collisionAt(state,p));hz.push(p)}return hz}

    function collisionAt(state,p){for(const s of state.snakes){for(const c of s.body){if(equal(c,p))return true}}if(state.hazards)for(const h of state.haz){if(equal(h,p))return true}if(state.foods)for(const f of state.foods){if(equal(f,p))return true}if(state.items)for(const it of state.items){if(equal(it,p))return true}return false}

    // Items
    const ITEM_TYPES=['shrink','bonus','clear'];
    function newItem(state){
      let p; let tries=0;
      do { p={x:rnd(state.cols), y:rnd(state.rows)}; tries++; if(tries>2000) break; }
      while(collisionAt(state,p));
      const type = ITEM_TYPES[rnd(ITEM_TYPES.length)];
      return {x:p.x,y:p.y,type};
    }

    // --- VFX: particles, popups, screen shake, flashes
    const FX = { particles:[], popups:[], shakeT:0, shakeI:0, flashT:0 };
    function spawnBurst(cx, cy, color, n=12, speed=1.6, size=3, life=18){
      for(let i=0;i<n;i++){
        const a = Math.random()*Math.PI*2;
        const v = (0.4+Math.random())*speed;
        FX.particles.push({x:cx, y:cy, vx:Math.cos(a)*v, vy:Math.sin(a)*v, life, max:life, size, color});
      }
    }
    function spawnPopup(x,y,text,color='#fff',life=30){ FX.popups.push({x,y,vy:-0.02,life,max:life,text,color}); }
    function shake(intensity=4, time=200){ FX.shakeI = Math.max(FX.shakeI, intensity); FX.shakeT = Math.max(FX.shakeT, time); }
    function flash(time=120){ FX.flashT = Math.max(FX.flashT, time); }

    function updateFX(dt){
      // particles
      FX.particles = FX.particles.filter(p=>{ p.x+=p.vx; p.y+=p.vy; p.vy+=0.02; p.life--; return p.life>0; });
      // popups
      FX.popups = FX.popups.filter(t=>{ t.y += t.vy*dt; t.life--; return t.life>0; });
      // timers
      FX.shakeT = Math.max(0, FX.shakeT - dt);
      FX.flashT = Math.max(0, FX.flashT - dt);
    }

    // Game lifecycle
    let STATE={};
    const MODES={SINGLE:'Single', LOCAL:'Local Versus'};

    function init(mode='SINGLE'){
      CFG.speed=clamp(Number(ui.speed.value),5,25);
      CFG.cols=clamp(Number(ui.cols.value),12,64);
      CFG.rows=clamp(Number(ui.rows.value),10,48);
      CFG.wrap=!!ui.wrap.checked;
      CFG.hazards=!!ui.hazards.checked;
      CFG.foodCount=clamp(Number(ui.foodCount.value),1,10);
      CFG.itemMax=clamp(Number(ui.itemMax.value),0,6);
      saveConfig();
      resizeCanvas();

      const s1=newSnake('P1','#7cf49a',{x:Math.floor(CFG.cols*0.25),y:Math.floor(CFG.rows/2)},'RIGHT');
      const snakes = [s1];
      if(mode==='LOCAL'){
        const s2=newSnake('P2','#6ea8fe',{x:Math.floor(CFG.cols*0.75),y:Math.floor(CFG.rows/2)},'LEFT');
        snakes.push(s2);
      }
      STATE={cols:CFG.cols,rows:CFG.rows,snakes,foods:[],items:[],haz:CFG.hazards?newHazards({cols:CFG.cols,rows:CFG.rows,snakes,foods:[],items:[]},Math.floor((CFG.cols*CFG.rows)/180)):[],hazards:CFG.hazards,mode,paused:false,over:false,tick:0,lastStep:0,hi:Number(localStorage.getItem('snake.multi.hi')||0)};
      for(let i=0;i<CFG.foodCount;i++)STATE.foods.push(newFood(STATE));
      FX.particles.length=0; FX.popups.length=0; FX.shakeT=0; FX.flashT=0; FX.shakeI=0;
      updateUI();
    }

    function updateUI(){
      ui.sbMode.textContent = STATE.mode=== 'SINGLE' ? MODES.SINGLE : MODES.LOCAL;
      ui.sb1.textContent = STATE.snakes[0]?.score ?? 0;
      ui.sb2.textContent = STATE.snakes[1]?.score ?? 0;
      ui.hi.textContent = STATE.hi;
      ui.speedLabel.textContent = CFG.speed;
      ui.foodsLabel.textContent = CFG.foodCount;
      ui.itemsLabel.textContent = `${STATE.items.length} on board`;
      ui.btnPause.textContent = STATE.paused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
      ui.btnPause.setAttribute('aria-pressed', STATE.paused);
      document.getElementById('modeName').style.color = STATE.mode==='SINGLE' ? '#f7d774' : '#6ea8fe';
    }

    // Input
    const keyDirs={'ArrowUp':'UP','ArrowDown':'DOWN','ArrowLeft':'LEFT','ArrowRight':'RIGHT','w':'UP','s':'DOWN','a':'LEFT','d':'RIGHT','W':'UP','S':'DOWN','A':'LEFT','D':'RIGHT'};
    window.addEventListener('keydown',e=>{
      if(e.code==='Space'){ STATE.paused=!STATE.paused; updateUI(); return; }
      const k=e.key; if(!keyDirs[k]) return; const dir=keyDirs[k];
      if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(k) && STATE.snakes[0]) setDir(STATE.snakes[0], dir);
      else if(STATE.snakes[1]) setDir(STATE.snakes[1], dir);
    });

    function setDir(snake,dir){ if(OPP[snake.dir]===dir) return; snake.pendingDir=dir; }

    // Step / Update
    function step(){
      for(const s of STATE.snakes){ if(!s.alive) continue; s.dir = s.pendingDir; }

      // maybe spawn items
      if(STATE.items.length < CFG.itemMax && Math.random() < 0.03){ STATE.items.push(newItem(STATE)); }

      for(const s of STATE.snakes){
        if(!s.alive) continue;
        const d=DIRS[s.dir];
        let next={x:s.body[0].x+d[0], y:s.body[0].y+d[1]};
        if(CFG.wrap) next = wrapPos(next);

        if(!CFG.wrap && !inBounds(next)) { kill(s,'wall'); continue; }
        if(hitSnake(next)) { kill(s,'snake'); continue; }
        if(CFG.hazards && hitHazard(next)) { kill(s,'hazard'); continue; }

        s.body.unshift(next);
        // Food
        let ateFood=false;
        STATE.foods = STATE.foods.filter(f => {
          if(equal(next,f)) { s.grow += 2; s.score += 10; ateFood=true; return false; }
          return true;
        });
        while(STATE.foods.length < CFG.foodCount) STATE.foods.push(newFood(STATE));
        if(ateFood){
          const cx = next.x*CFG.cell+CFG.cell/2, cy = next.y*CFG.cell+CFG.cell/2;
          spawnBurst(cx, cy, '#ffd166', 16, 1.3, 2.8, 20);
          spawnPopup(cx, cy-6, '+10', '#ffd166');
        }

        // Items
        STATE.items = STATE.items.filter(it => {
          if(equal(next,it)) { applyItem(it.type, s, next); return false; }
          return true;
        });

        if(s.grow>0) s.grow--; else s.body.pop();
      }

      const maxScore = Math.max(STATE.snakes[0]?.score||0, STATE.snakes[1]?.score||0);
      if(maxScore>STATE.hi){ STATE.hi = maxScore; localStorage.setItem('snake.multi.hi', String(STATE.hi)); }

      updateUI();
    }

    function applyItem(type, snake, pos){
      const cx = pos ? pos.x*CFG.cell+CFG.cell/2 : snake.body[0].x*CFG.cell+CFG.cell/2;
      const cy = pos ? pos.y*CFG.cell+CFG.cell/2 : snake.body[0].y*CFG.cell+CFG.cell/2;
      if(type==='shrink'){
        const keep = Math.max(2, Math.ceil(snake.body.length*0.7));
        snake.body = snake.body.slice(0, keep);
        snake.grow = Math.max(0, snake.grow - 2);
        spawnBurst(cx, cy, '#b388ff', 20, 1.2, 3, 24);
        spawnPopup(cx, cy-6, 'Shrink!', '#b388ff');
        shake(3,120);
      } else if(type==='bonus'){
        snake.score += 50;
        spawnBurst(cx, cy, '#4dd0e1', 18, 1.4, 3, 22);
        spawnPopup(cx, cy-6, '+50', '#4dd0e1');
      } else if(type==='clear'){
        STATE.haz = [];
        spawnBurst(cx, cy, '#ffcccb', 26, 1.0, 3, 26);
        spawnPopup(cx, cy-6, 'Cleared!', '#ffcccb');
        flash(140); shake(4,160);
      }
    }

    function hitSnake(p){ for(const s of STATE.snakes){ for(const c of s.body){ if(equal(c,p)) return true; } } return false; }
    function hitHazard(p){ for(const h of STATE.haz){ if(equal(h,p)) return true; } return false; }

    function kill(s, reason='other'){
      if(s.alive){
        const h = s.body[0];
        const cx=h.x*CFG.cell+CFG.cell/2, cy=h.y*CFG.cell+CFG.cell/2;
        const col = reason==='hazard' ? '#ff6b6b' : '#ffffff';
        spawnBurst(cx, cy, col, 24, 1.6, 3.2, 26);
        shake(6,220); flash(120);
      }
      s.alive=false;
    }

    // Draw
    function drawCell(x,y,fill){ ctx.fillStyle=fill; ctx.fillRect(x*CFG.cell+1,y*CFG.cell+1,CFG.cell-2,CFG.cell-2); }

    function draw(){
      // screen shake
      const shakeX = FX.shakeT>0 ? (Math.random()*2-1)*FX.shakeI : 0;
      const shakeY = FX.shakeT>0 ? (Math.random()*2-1)*FX.shakeI : 0;
      ctx.save();
      ctx.translate(shakeX, shakeY);

      ctx.clearRect(-shakeX,-shakeY,canvas.width+Math.abs(shakeX),canvas.height+Math.abs(shakeY));

      // Hazards
      if(STATE.hazards){
        for(const h of STATE.haz){
          const x=h.x*CFG.cell, y=h.y*CFG.cell; 
          ctx.strokeStyle='#ff6b6b'; ctx.lineWidth=3; ctx.beginPath();
          ctx.moveTo(x+4,y+4); ctx.lineTo(x+CFG.cell-4,y+CFG.cell-4);
          ctx.moveTo(x+CFG.cell-4,y+4); ctx.lineTo(x+4,y+CFG.cell-4);
          ctx.stroke();
        }
      }

      // Food
      for(const f of STATE.foods){
        drawCell(f.x,f.y,'#ffd166');
        ctx.strokeStyle='rgba(255,209,102,0.9)'; ctx.lineWidth=2;
        ctx.strokeRect(f.x*CFG.cell+1.5,f.y*CFG.cell+1.5,CFG.cell-3,CFG.cell-3);
      }

      // Items
      for(const it of STATE.items){
        const x=it.x*CFG.cell, y=it.y*CFG.cell;
        if(it.type==='shrink'){
          ctx.fillStyle='#b388ff'; ctx.fillRect(x+4,y+4,CFG.cell-8,CFG.cell-8);
          ctx.strokeStyle='white'; ctx.strokeRect(x+6,y+6,CFG.cell-12,CFG.cell-12);
        } else if(it.type==='bonus'){
          ctx.fillStyle='#4dd0e1'; ctx.beginPath(); ctx.arc(x+CFG.cell/2,y+CFG.cell/2,CFG.cell*0.35,0,Math.PI*2); ctx.fill();
          ctx.strokeStyle='white'; ctx.beginPath(); ctx.moveTo(x+CFG.cell/2, y+6); ctx.lineTo(x+CFG.cell/2, y+CFG.cell-6); ctx.stroke();
        } else if(it.type==='clear'){
          ctx.fillStyle='#ffcccb'; ctx.fillRect(x+4,y+4,CFG.cell-8,CFG.cell-8);
          ctx.strokeStyle='#333'; ctx.beginPath(); ctx.moveTo(x+6,y+CFG.cell-6); ctx.lineTo(x+CFG.cell-6,y+6); ctx.stroke();
        }
      }

      // Snakes
      for(const s of STATE.snakes){
        ctx.globalAlpha = s.alive?1:0.4;
        for(let i=0;i<s.body.length;i++){
          const c = s.body[i];
          const shade = i===0 ? s.color : shadeHex(s.color, -12);
          drawCell(c.x, c.y, shade);
        }
        ctx.globalAlpha = 1;
      }

      // Particles (on top of board)
      for(const p of FX.particles){
        const t = p.life/p.max; // 1..0
        ctx.globalAlpha = Math.max(0, t);
        ctx.fillStyle = p.color || '#fff';
        ctx.beginPath();
        ctx.arc(p.x, p.y, Math.max(1, p.size*t), 0, Math.PI*2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      // Popups
      ctx.font = 'bold 14px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Arial';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      for(const t of FX.popups){
        const a = t.life/t.max;
        ctx.globalAlpha = Math.max(0, a);
        ctx.fillStyle = t.color; ctx.fillText(t.text, t.x, t.y);
      }
      ctx.globalAlpha = 1;

      ctx.restore();

      // Flash overlay
      if(FX.flashT>0){
        const a = Math.min(0.35, FX.flashT/140*0.35);
        ctx.fillStyle = `rgba(255,255,255,${a.toFixed(3)})`;
        ctx.fillRect(0,0,canvas.width,canvas.height);
      }

      // advance VFX
      updateFX(16);
    }

    function shadeHex(hex,percent){
      const v=hex.replace('#',''); let r=parseInt(v.slice(0,2),16), g=parseInt(v.slice(2,4),16), b=parseInt(v.slice(4,6),16);
      const f=x=>clamp(Math.round(x+255*(percent/100)),0,255); r=f(r); g=f(g); b=f(b);
      return `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;
    }

    // Main loop
    function loop(ts){
      if(!STATE.paused){
        const interval=1000/CFG.speed;
        if(ts-STATE.lastStep>=interval){ STATE.lastStep=ts; step(); }
      }
      draw(); requestAnimationFrame(loop);
    }

    // UI
    ui.speed.addEventListener('input',()=>{ ui.speedLabel.textContent=ui.speed.value; CFG.speed=Number(ui.speed.value); saveConfig(); });
    ui.cols.addEventListener('change',()=>{ CFG.cols=clamp(Number(ui.cols.value),12,64); saveConfig(); resizeCanvas(); init(STATE.mode); });
    ui.rows.addEventListener('change',()=>{ CFG.rows=clamp(Number(ui.rows.value),10,48); saveConfig(); resizeCanvas(); init(STATE.mode); });
    ui.wrap.addEventListener('change',()=>{ CFG.wrap=!!ui.wrap.checked; saveConfig(); });
    ui.hazards.addEventListener('change',()=>{ CFG.hazards=!!ui.hazards.checked; saveConfig(); init(STATE.mode); });
    ui.foodCount.addEventListener('change',()=>{ CFG.foodCount=clamp(Number(ui.foodCount.value),1,10); ui.foodsLabel.textContent=CFG.foodCount; saveConfig(); init(STATE.mode); });
    ui.itemMax.addEventListener('change',()=>{ CFG.itemMax=clamp(Number(ui.itemMax.value),0,6); saveConfig(); });

    ui.btnPause.addEventListener('click',()=>{ STATE.paused=!STATE.paused; updateUI(); });
    ui.btnRestart.addEventListener('click',()=>{ init(STATE.mode); });
    ui.btnSingle.addEventListener('click',()=>{ init('SINGLE'); });
    ui.btnLocal.addEventListener('click',()=>{ init('LOCAL'); });

    // Init
    resizeCanvas();
    ui.speed.value=CFG.speed; ui.speedLabel.textContent=CFG.speed; ui.cols.value=CFG.cols; ui.rows.value=CFG.rows; ui.wrap.checked=CFG.wrap; ui.hazards.checked=CFG.hazards; ui.foodCount.value=CFG.foodCount; ui.foodsLabel.textContent=CFG.foodCount; ui.itemMax.value=CFG.itemMax;
    init('SINGLE'); requestAnimationFrame(loop);
  })();
  </script>
</body>
</html>
